# x86-to-C Interface Programming Project

Task: Implement a program that converts a grayscale image from float-based representation to integer-based representation using C and x86-64 assembly language.

---

## Input

* `height` (number of rows)
* `width` (number of columns)
* Float pixel values of the grayscale image

## Output

* Integer pixel values (0–255) corresponding to the float values scaled appropriately

---

## Run Program

1. Make sure `build.bat` is in the same directory as the source files.
2. Open **Command Prompt**, navigate to the project folder.
3. Execute the batch file:

   ```cmd
   build.bat
   ```
---

## Recorded Execution Times

Recorded average execution time results in **30 runs** in milliseconds in **Assembly**:

| Width | Height | Avg Execution Time (ms) |
| ----- | ------ | ----------------------- |
| 10    | 10     |       0.00015000        |
| 100   | 100    |       0.01082333        |
| 1000  | 1000   |       1.55232000        |


Recorded average execution time results in **30 runs** in milliseconds in **C**:

| Width | Height | Avg Execution Time (ms) |
| ----- | ------ | ----------------------- |
| 10    | 10     |       0.00047667        |
| 100   | 100    |       0.03965000        |
| 1000  | 1000   |       4.10932000        |

Raw execution time data is available in:
- `data/run_times.xlsx`

## Execution Time Analysis

Based on the measured execution run times using **QueryPerformanceCounter** on Windows over 30 runs, there is a clear linear relationship between image size (the number of pixels) and the time it takes to perform the float-to-integer conversion for both the Assembly and C implementation. All tests were conducted on Microsoft Visual Studio.

As the image size increases, the execution time increases proportionally:
* A 10×10 image (100 pixels) completes in approximately **~0.00015 ms** in Assembly and **~0.00048 ms** in C.
* A 100×100 image (10,000 pixels) completes in about **~0.01082 ms** in Assembly and **~0.03965 ms** in C.
* A 1000×1000 image (1,000,000 pixels) completes in around **~1.55232 ms** in Assembly and **~4.10932 ms** in C.

From these values, the scaling pattern is consistent:
- Increasing the pixel count by 100x (100 → 10,000) increases runtime by ~100x.
- Increasing by another 100x (10,000 → 1,000,000) again increases runtime by ~100x.

This shows that the conversion function scales predictably with image size.

### Performance Difference
Across all tested image sizes, the Assembly implementation is consistently faster:
| Image Size | Speedup (C÷Assembly)  |
| ---------- | --------------------- |
| 10x10      |     ~3.18× faster     |
| 100x100    |     ~3.66x faster     |
| 1000x1000  |     ~2.65x faster     |

A few factors can explain why the Assembly implementation performs faster than the C version. Assembly implementation performs the conversion using direct register operations and efficient scalar SSE instructions (movss, mulss, cvtss2si), avoiding the extra instructions and temporary values generated by the C compiler. Memory access is minimized, and the loop is tightly optimized through manual register control and simple branching. These low-level optimizations reduce per-pixel overhead, allowing the Assembly version of the float-to-integer conversion to run significantly faster than the C implementation.

---

## Screenshot of Sample Program Output

![Sample Output](assets/sample-output-screenshot.png)

---
## Author
* Kristine Magdalene J. Cayanan